<?php addBr('Регулярные выражения - это такие команды для сложного поиска и замены. Они позволяют делать очень интересные вещи, но, к сожалению, довольно тяжелы в освоении.');hr();
addBr('Функция ' .rB('preg_replace') . 'Эта функция первым параметром принимает что менять, а вторым - на что менять, а третьим параметром - строку, в которой нужно заменять:');

addBr(rB('Синтаксис: ') .'preg_replace(что менять, на что, строка);');
addBr('');
echo(rI('первым параметром наша функция принимает не просто строку, а регулярное выражение, представляющее собой строку с набором команд, расположенных внутри символов решетки #. Эти решетки называются ограничителями регулярных выражений.
После ограничителей можно писать модификаторы - команды, которые изменяют общие свойства регулярного выражения. Сами регулярные выражения состоят из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются специальные символы. Буквы и цифры обозначают сами себя. В следующем примере мы с помощью регулярного выражения заменим букву '."'a'".' на '."'!' : "));

$str = preg_replace('#a#', '!', 'bab'); // вернет 'b!b'
addBr(aC("preg_replace('#a#', '!', 'bab')") . " = ". $str);
addBr('');

echo(rI('А вот точка является специальным символом и обозначает любой символ. В следующем примере мы найдем строку по такому шаблону: буква '."'x'".', затем любой символ, затем опять буква '."'x'".' : '));
$str = preg_replace('#x.x#', '!', 'xax eee'); // вернет '! eee'
addBr(aC("preg_replace('#x.x#', '!', 'xax eee')") . " = ". $str);
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	".'$str'." = 'ahb acb aeb aeeb adcb axeb'; ". "Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb' по шаблону: буква 'a', любой символ, буква 'b'.");
$str = preg_replace('#a.b#', ' "a!b" ', 'ahb acb aeb aeeb adcb axeb'); 
addBr(aC("preg_replace('#a.b#', '\"a!b\"', 'ahb acb aeb aeeb adcb axeb')") . " = ". $str);
addBr('');
addBr("Дана строка:	".'$str'." = 'ahb acb aeb aeeb adcb axeb'; ". "Напишите регулярку, которая найдет строки 'aeeb', 'adcb', 'axeb' по шаблону: буква 'a', два любых символа, буква 'b'.");
$str = preg_replace('#a..b#', ' "a!!b" ', 'ahb acb aeb aeeb adcb axeb'); 
addBr(aC("preg_replace('#a..b#', '\"a!!b\"', 'ahb acb aeb aeeb adcb axeb')") . " = ". $str);
hr();
addBr(rB('Операторы повторения символов в регулярках'));
addBr('Бывают ситуации, когда мы хотим указать, что символ повторяется заданное количество раз. Если мы знаем точное число повторений, то можно просто написать его несколько раз - #aaaa#. Но что делать, если мы хотим сказать такое: повторить один или более раз? Для этого существуют операторы (квантификаторы) повторения: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними. Давайте посмотрим на работу этих операторов на примере.');

addBr(aC('	$str = '."'xx xax xaax xaaax xbx'".'; <br/> $res = preg_replace('."'#xa+x#'".', '."'!'".', $str);'));
$str = 'xx xax xaax xaaax xbx';
$res = preg_replace(' #xa+x#', '!', $str);
addBr(aC('echo $res').' = '. $res);
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один или более раз , буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));

$result = preg_replace('#ab+a#','!',$str);
addBr(aC("preg_replace('#ab+a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' ноль или более раз, буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab*a#','!',$str);
addBr(aC("preg_replace('#ab*a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один раз или ниодного, буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab?a#','!',$str);
addBr(aC("preg_replace('#ab?a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки 'aa', 'aba', 'abba', 'abbba', не захватив 'abca' и 'abea'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab*a#','!',$str);
addBr(aC("preg_replace('#ab*a#','!',$str)").' = '. $result);
hr();


addBr(rB('Группирующие скобки в регулярках PHP'));
addBr("В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если мы хотим подействовать им на несколько символов? Для этого существуют группирующие скобки '(' и ')'. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок. <br/>В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x':");
addBr(aC("	".'$str'." = 'xabx xababx xaabbx';<br/>
".'$res'." = preg_replace('#x(ab)+x#', '!', ".'$str'.");"));
addBr(aC('echo $res').' = '. preg_replace('#x(ab)+x#', '!', 'xabx xababx xaabbx'));

addBr(rB('Задача'));
addBr("Дана строка:	" . '$str' . " = 'ab abab abab abababab abea'; " . "Напишите регулярку, которая найдет строки по шаблону: строка 'ab' повторяется 1 или более раз.");
$str = 'ab abab abab abababab abea';
$result = preg_replace('#(ab)+#', '!', $str);
addBr(aC("preg_replace('#(ab)#','!','ab abab abab abababab abea')") . ' = ' . $result);
hr();
addBr(rB('Экранировка спецсимволов в регулярках PHP'));
addBr("Предположим, что мы хотим сделать так, чтобы спецсимвол обозначал сам себя. Для этого его нужно экранировать с помощью обратного слеша. Давайте посмотрим на примерах.");
addBr(aC("preg_replace('#a\+x#', '!', 'a+x ax aax aaax');").' = '. preg_replace('#a\+x#', '!', 'a+x ax aax aaax'));
hr();


addBr(rB('Список специальных символов в регулярках в PHP'));
addBr("Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать.
Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).<br/>
 ". rB('Являются спецсимволами: $ ^ . * + ? \ / {} [] () |').'<br/>'.
 rB('Не являются спецсимволами: @ : , '."' ". " ; - _ = < > % # ~ ` & !"));
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	" . '$str' . " = 'a.a aba aea'; " . "Напишите регулярку, которая найдет строку 'a.a', не захватив остальные.");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '2+3 223 2223'; " . "Напишите регулярку, которая найдет строку '2+3', не захватив остальные.");
addBr(aC("preg_replace('#2\+3#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#2\+3#', '!', '2+3 223 2223'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '23 2+3 2++3 2+++3 345 567'; " . "Напишите регулярку, которая найдет строки '2+3', '2++3', '2+++3', не захватив остальные (+ может быть любое количество).");
addBr(aC("preg_replace('#2\++3#', 'туть ', '23 2+3 2++3 2+++3 345 567');") . ' = ' . preg_replace('#2\++3#', 'туть ', '23 2+3 2++3 2+++3 345 567'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '23 2+3 2++3 2+++3 345 567'; " . "Напишите регулярку, которая найдет строки '23', '2+3', '2++3', '2+++3', не захватив остальные.");
addBr(aC("preg_replace('#2\+*3#', 'туть ', '23 2+3 2++3 2+++3 345 567');") . ' = ' . preg_replace('#2\+*3#', 'туть ', '23 2+3 2++3 2+++3 345 567'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '*+ *q+ *qq+ *qqq+ *qqq qqq+'; " . "Напишите регулярку, которая найдет строки '*q+', '*qq+', '*qqq+', не захватив остальные.");
addBr(aC("preg_replace('#\*q+\+#', 'туть ', '*+ *q+ *qq+ *qqq+ *qqq qqq+');") . ' = ' . preg_replace('#\*q+\+#', 'туть ', '*+ *q+ *qq+ *qqq+ *qqq qqq+'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '[abc] {abc} abc (abc) [abc]'; " . "Напишите регулярку, которая найдет строки в квадратных скобках и заменят их на 'туть '.");
addBr(aC("preg_replace('#\[abc*\]#', 'туть ', '[abc] {abc} abc (abc) [abc]');") . ' = ' . preg_replace('#\[abc\]#', 'туть ', '[abc] {abc} abc (abc) [abc]'));
hr();


addBr(rB('Фигурные скобки в регулярных выражения PHP'));
addBr("Операторы +, *, ? хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет оператор {}.
<br/>
<br/>
". rB('Работает он следующим образом:')." {5} - пять повторений, {2,5} - повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз.");
addBr(aC("	" . '$str' . " = 'xx xax xaax xaaax';<br/>
" . '$res' . " = preg_replace('#xa{1,2}x#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' . preg_replace('#xa{1,2}x#', '!', 'xx xax xaax xaaax'));
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки 'abba', 'abbba', 'abbbba' и только их.");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{2,4}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{2,4}a#', 'туть ', 'aa aba abba abbba abbbba abbbbba'));

addBr('');
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается менее трех раз (включительно).");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{0,3}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{0,3}a#', 'туть ', 'aa aba abba abbba abbbba abbbbba'));

addBr('');
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается более четырех раз (включительно).");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{4,}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{4,}a#', rB('туть '), 'aa aba abba abbba abbbba abbbbba'));
hr();


addBr(rB('Ограничение жадности в регулярках в PHP'));
addBr("Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов.");
addBr("Давайте посмотрим на примере. Пусть у нас есть вот такая строка:");
addBr(aC("	".'$str'." = 'aeeex zzz x kkk';"));
addBr("Пусть мы в этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x'.");
addBr(aC('$res'." = preg_replace('#a.+x#', '!', ".'$str'.");"));
addBr("Мы ожидаем, что в переменную в результате запишется строка '! zzz x kkk'. Однако, это не так - в переменную попадает строка '! kkk'.
<br/>
Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'. Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что мы ожидали.
<br/>
Конечно, зачастую такое поведение нам и нужно. Но конкретно в этом случае мы бы хотели отменить жадность и сказать регулярке, чтобы она искала до первого икса.
<br/>
Чтобы ограничить жадность, нужно после оператора повторения поставить знак вопроса:");
addBr(aC('$res'." = preg_replace('#a.+?x#', '!', ".'$str'.");"));
addBr("Тогда мы получим изначально запланированный результат:");
echo(aC('echo $res').' = '. preg_replace('#a.+?x#', '!','aeeex zzz x kkk'));
hr();
addBr(rB("Жадность можно ограничивать всем операторам повторения, вот так: *?, ?? и {}?."));
hr();

addBr(rB('Задача'));
addBr("Дана строка:	" . '$str' . " = 'aba accca azzza wwwwa'; " . "Напишите регулярку, которая найдет все строки по краям которых стоят буквы 'a', и заменит каждую из них на '!'. Между буквами a может быть любой символ (кроме 'a').");
addBr(aC("preg_replace('#a.+?a#', 'туть ', 'aba accca azzza wwwwa');") . ' = ' . preg_replace('#a.+?a#', 'туть ', 'aba accca azzza wwwwa'));
hr();
addBr(rB('Группы символов в регулярных выражениях PHP'));
addBr('Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. '.rB('Команда \d').' означает цифру от 0 до 9. '.rB('Команда \w').' обозначает цифру, латинскую букву или знак подчеркивания. '.rB('Команда \s').' обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию. '.rB('Можно инвертировать значение команды').', написав большую букву: например, если '.rB('\d - цифра').', то '.rB('\D - не цифра').'.');

addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aa a1a a2a a3a a4a a5a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними одна цифра.");
$str = 'aa a1a a2a a3a a4a a5a aba aca';
addBr(aC('$str = ' . "'a1a a2a a3a a4a a5a aba aca';"));
$result = preg_replace('#a\da#', 'туть ', $str);
addBr(aC("preg_replace('#a\da#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aa a1a a22a a333a a4444a a55555a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр.");
$str = 'aa a1a a22a a333a a4444a a55555a aba aca';
addBr(aC('$str = ' . "'aa a1a a22a a333a a4444a a55555a aba aca';"));
$result = preg_replace('#a\d+?a#', 'туть ', $str);
addBr(aC("preg_replace('#a\d+?a#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aa a1a a22a a333a a4444a a55555a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр (в том числе и ноль цифр, то есть строка 'aa').");
$str = 'aa a1a a22a a333a a4444a a55555a aba aca';
addBr(aC('$str = ' . "'aa a1a a22a a333a a4444a a55555a aba aca';"));
$result = preg_replace('#a\d*?a#', 'туть ', $str);
addBr(aC("preg_replace('#a\d*?a#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'avb a1b a2b a3b a4b a5b abb acb'; " . "Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не число.");
$str = 'avb a1b a2b a3b a4b a5b abb acb';
addBr(aC('$str = ' . "'avb a1b a2b a3b a4b a5b abb acb';"));
$result = preg_replace('#a\Db#', 'туть ', $str);
addBr(aC("preg_replace('#a\Db#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'ave a#b a2b a\$b a4b a5b a-b acb'; " . "Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не буква и не цифра.");
$str = 'ave a#b a2b a$b a4b a5b a-b acb';
addBr(aC('$str = ' . "'ave a#b a2b a\$b a4b a5b a-b acb';"));
$result = preg_replace('#a\Wb#', 'туть ', $str);
addBr(aC("preg_replace('#a\Wb#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'ave a#a a2a a\$a a4a a5a a-a aca'; " . "Напишите регулярку, которая заменит все пробелы на '!'.");
$str = 'ave a#b a2b a$b a4b a5b a-b acb';
addBr(aC('$str = ' . "'ave a#b a2b a\$b a4b a5b a-b acb';"));
$result = preg_replace('#\s#', '!', $str);
addBr(aC("preg_replace('#\s#','!',$str)") . ' = ' . $result);
hr();


addBr(rB('Наборы символов в регулярных выражениях PHP'));
addBr("Группы символов ".rB('\d'). " и " . rB('\w')." не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать квадратные скобки, представляющие собой операцию ИЛИ.<br/>
Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: #x[abc]x# - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.<br/>
После квадратных скобок можно писать операторы повторения. К примеру, вот так: ".rB('#x[abc]+x#'). " - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.<br/>
Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. К примеру, вот так: " . rB('#[a-d]#')." - мы получаем все символы от 'a' до 'd'.");
// Примеры: 
// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:
// $str = 'xax x1x x3x x5x x@x';
// $res = preg_replace('#x[a-z1-9]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! ! x@x'

// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':
// $str = 'xax xBx xcx x5x x@x';
// $res = preg_replace('#x[a-zA-Z]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! x5x x@x'

// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:
// $str = 'xax xbx x1x x2x x3x';
// $res = preg_replace('#x[a-z12]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! ! x3x'
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aba aea aca aza axa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква 'b', 'e' или 'x'.");
$str = 'aba aea aca aza axa';
addBr(aC('$str = ' . "'aba aea aca aza axa';"));
$result = preg_replace('#a[bex]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[bex]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'a1a a3a a7a a9a aba'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - цифра от 3-х до 6-ти.");
$str = 'a1a a3a a7a a9a aba';
addBr(aC('$str = ' . "'a1a a3a a7a a9a aba';"));
$result = preg_replace('#a[3-6]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[3-6]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aba aea afa aha aga'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до g.");
$str = 'aba aea afa aha aga';
addBr(aC('$str = ' . "'aba aea afa aha aga';"));
$result = preg_replace('#a[a-g]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-g]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aba aea afa aha aga'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от j до z.");
$str = 'aba aea afa aha aga';
addBr(aC('$str = ' . "'aba aea afa aha aga';"));
$result = preg_replace('#a[a-fj-z]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-fj-z]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAa aea aEa aJa a3a'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от A до D.");
$str = 'aAa aea aEa aJa a3a';
addBr(aC('$str = ' . "'aAa aea aEa aJa a3a';"));
$result = preg_replace('#a[a-fA-D]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-fA-D]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-z]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-z]+a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие и большие латинские буквы, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-zA-Z]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-zA-Z]+a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы и цифры, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-z0-9]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-z0-9]+a#','туть ','$str')") . ' = ' . $result);
// addBr('');
hr('');


addBr(rB('Инвертирование наборов символов в регулярках'));
addBr("С помощью шляпки ^ в начале квадратных скобок можно инвертировать желаемое. То есть, если, к примеру, команда ".rB('[ab]'). " ищет букву 'a' или 'b', то команда " . rB('[^ab]')." будет искать все символы, кроме 'a' и 'b'.");

addBr('');
addBr(rB('Практические задачи'));
addBr("Напишите регулярку, которая найдет строки по шаблону: цифра '1', затем символ не 'e' и не 'x', цифра '2'.");
$str = '1e2 1ex2 132 1ab abc4';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4';"));
$result = preg_replace('#1[^ex]2#', 'туть ', $str);
addBr(aC("preg_replace('#1[^ex]2#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ цифра от 2 до 7, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^2-7]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^2-7]z#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая латинская буква от 1 и более раз, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^A-Z+]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^A-Z+]z#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем не большая и не маленькая латинская буква и не цифра от 1 до 5 от 1 и более раз, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^A-Za-z1-5+]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^A-Za-z1-5+]z#','туть ','$str')") . ' = ' . $result);
hr('');


addBr(rB('Особенности кириллицы в регулярках PHP'));
addBr("Кириллические символы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я]. Но даже с этой группой есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно сделать вот так: " . rB('[а-яё].')

.rB('Для корректной работы кириллицы в регулярке необходимо поставить модификатор u:'));
addBr("");
addBr(aC("	".'$str'." = 'яяя ййй ёёё';<br/>
	".'$res'." = preg_replace('#[а-яё]#u', '!', ".'$str'.");"));

addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'wйw wяw wёw wqw'; " . "Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'w', а между ними - буква кириллицы.");
$str = 'wйw wяw wёw wqw';
addBr(aC('$str = ' . "'wйw wяw wёw wqw';"));
$result = preg_replace('#w[а-яё]w#u', 'туть ', $str);
addBr(aC("preg_replace('#w[а-яё]w#u','туть ','$str')") . ' = ' . $result);

addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ'; " . "Напишите регулярку, которая найдет все слова по шаблону: любая кириллическая буква любое количество раз.");
$str = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';
addBr(aC('$str = ' . "'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';"));
$result = preg_replace('#[а-яёА-ЯЁ]+#u', 'туть ', $str);
addBr(aC("preg_replace('#[а-яёА-ЯЁ]+#u','туть ','$str')") . ' = ' . $result);
hr();

addBr(rB('Спецсимволы внутри квадратных скобок в PHP'));
addBr("Спецсимволы внутри [] становятся обычными символами. Это значит, что ".rB('их не надо экранировать обратным слешем.'));
// Пример: В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:
// $str = 'xax xbx xcx xdx x.x x@x';
// $res = preg_replace('#x[abc.]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! xdx ! x@x'

// Пример: В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или точка:
// $str = 'xax xbx xcx x@x';
// $res = preg_replace('#x[a-z.]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! x@x'
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aba aea aca aza axa a.a a+a a*a'; " . "Напишите регулярку, которая найдет строки 'a.a', 'a+a', 'a*a', не затронув остальных.");
$str = 'aba aea aca aza axa a.a a+a a*a';
addBr(aC('$str = ' . "'aba aea aca aza axa a.a a+a a*a';"));
$result = preg_replace('#.[+.*]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[+.*]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'xaz x.z x3z x@z x\$z xrz'; " . "Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ точка, НЕ собака, и НЕ доллар, а потом буква 'z'.");
$str = 'xaz x.z x3z x@z x$z xrz';
addBr(aC('$str = ' . "'xaz x.z x3z x@z x\$z xrz';"));
$result = preg_replace('#x[^.@$]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^.@$]z#','туть ','$str')") . ' = ' . $result);
hr();

addBr(rB('Группы символов внутри квадратных скобок PHP'));
addBr("Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами.");
// Пример: В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':
// $str = 'xax xbx x1x x2x xhx x@x';
// $res = preg_replace('#x[\da-f]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! ! xhx x@x'

// Пример: В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z':
// $str = 'xaz x1z xAz x.z x@z';
// $res = preg_replace('#x[^\d.a-z]z#', '!', $str);
// В результате в переменную запишется следующее:'xaz x1z ! x.z !'

// addBr(rB('Практические задачи'));
// addBr("Дана строка:	" . '$str' . " = 'aba 11 . aza .. a.a a+a a*a'; " . "Напишите регулярку, которая найдет строки по шаблону: цифра или точка от 1 и более раз.");
// $str = 'aba 11 . aza .. a.a a+a a*a';
// addBr(aC('$str = ' . "'aba 11 . aza .. a.a a+a a*a';"));
// $result = preg_replace('#[\d.]#', 'туть ', $str);
// addBr(aC("preg_replace('#[\d.]+#','туть ','$str')") . ' = ' . $result);
// addBr('');
// addBr("Дана строка:	" . '$str' . " = 'mm 11 . zzz .. 888 a+a a*a'; " . "Напишите регулярку, которая найдет строки по шаблону: не цифра и не буква от 'a' до 'g' от 3 до 7 раз.");
// $str = 'mm 11 . zzz .. 888 a+a a*a';
// addBr(aC('$str = ' . "'mm 11 . zzz .. 888 a+a a*a';"));
// $result = preg_replace('#[^a-g3-7]#', 'туть ', $str);
// addBr(aC("preg_replace('#[^a-g3-7]#','туть ','$str')") . ' = ' . $result);
// addBr('');


?>