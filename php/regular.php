<?php addBr('Регулярные выражения - это такие команды для сложного поиска и замены. Они позволяют делать очень интересные вещи, но, к сожалению, довольно тяжелы в освоении.');hr();
addBr('Функция ' .rB('preg_replace') . 'Эта функция первым параметром принимает что менять, а вторым - на что менять, а третьим параметром - строку, в которой нужно заменять:');

addBr(rB('Синтаксис: ') .'preg_replace(что менять, на что, строка);');
addBr('');
echo(rI('первым параметром наша функция принимает не просто строку, а регулярное выражение, представляющее собой строку с набором команд, расположенных внутри символов решетки #. Эти решетки называются ограничителями регулярных выражений.
После ограничителей можно писать модификаторы - команды, которые изменяют общие свойства регулярного выражения. Сами регулярные выражения состоят из двух типов символов: из тех, которые обозначают сами себя и из символов-команд, которые называются специальные символы. Буквы и цифры обозначают сами себя. В следующем примере мы с помощью регулярного выражения заменим букву '."'a'".' на '."'!' : "));

$str = preg_replace('#a#', '!', 'bab'); // вернет 'b!b'
addBr(aC("preg_replace('#a#', '!', 'bab')") . " = ". $str);
addBr('');

echo(rI('А вот точка является специальным символом и обозначает любой символ. В следующем примере мы найдем строку по такому шаблону: буква '."'x'".', затем любой символ, затем опять буква '."'x'".' : '));
$str = preg_replace('#x.x#', '!', 'xax eee'); // вернет '! eee'
addBr(aC("preg_replace('#x.x#', '!', 'xax eee')") . " = ". $str);
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	".'$str'." = 'ahb acb aeb aeeb adcb axeb'; ". "Напишите регулярку, которая найдет строки 'ahb', 'acb', 'aeb' по шаблону: буква 'a', любой символ, буква 'b'.");
$str = preg_replace('#a.b#', ' "a!b" ', 'ahb acb aeb aeeb adcb axeb'); 
addBr(aC("preg_replace('#a.b#', '\"a!b\"', 'ahb acb aeb aeeb adcb axeb')") . " = ". $str);
addBr('');
addBr("Дана строка:	".'$str'." = 'ahb acb aeb aeeb adcb axeb'; ". "Напишите регулярку, которая найдет строки 'aeeb', 'adcb', 'axeb' по шаблону: буква 'a', два любых символа, буква 'b'.");
$str = preg_replace('#a..b#', ' "a!!b" ', 'ahb acb aeb aeeb adcb axeb'); 
addBr(aC("preg_replace('#a..b#', '\"a!!b\"', 'ahb acb aeb aeeb adcb axeb')") . " = ". $str);
hr();
addBr(rB('Операторы повторения символов в регулярках'));
addBr('Бывают ситуации, когда мы хотим указать, что символ повторяется заданное количество раз. Если мы знаем точное число повторений, то можно просто написать его несколько раз - #aaaa#. Но что делать, если мы хотим сказать такое: повторить один или более раз? Для этого существуют операторы (квантификаторы) повторения: плюс + (один и более раз), звездочка * (ноль или более раз) и вопрос ? (ноль или один раз). Эти операторы действуют на тот символ, который стоит перед ними. Давайте посмотрим на работу этих операторов на примере.');

addBr(aC('	$str = '."'xx xax xaax xaaax xbx'".'; <br/> $res = preg_replace('."'#xa+x#'".', '."'!'".', $str);'));
$str = 'xx xax xaax xaaax xbx';
$res = preg_replace(' #xa+x#', '!', $str);
addBr(aC('echo $res').' = '. $res);
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один или более раз , буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));

$result = preg_replace('#ab+a#','!',$str);
addBr(aC("preg_replace('#ab+a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' ноль или более раз, буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab*a#','!',$str);
addBr(aC("preg_replace('#ab*a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки по шаблону: буква 'a', буква 'b' один раз или ниодного, буква 'a'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab?a#','!',$str);
addBr(aC("preg_replace('#ab?a#','!',$str)").' = '. $result);

addBr('');
addBr("Дана строка:	".'$str'. " = 'aa aba abba abbba abca abea'; ". "Напишите регулярку, которая найдет строки 'aa', 'aba', 'abba', 'abbba', не захватив 'abca' и 'abea'.");
$str = 'aa aba abba abbba abca abea';
addBr(aC('$str = '."'aa aba abba abbba abca abea';"));
$result = preg_replace('#ab*a#','!',$str);
addBr(aC("preg_replace('#ab*a#','!',$str)").' = '. $result);
hr();


addBr(rB('Группирующие скобки в регулярках PHP'));
addBr("В предыдущих примерах операторы повторения действовали только на один символ, который стоял перед ними. Что делать, если мы хотим подействовать им на несколько символов? Для этого существуют группирующие скобки '(' и ')'. Они работают так: если что-то стоит в группирующих скобках и сразу после ')' стоит оператор повторения - он подействует на все, что стоит внутри скобок. <br/>В следующем примере шаблон поиска выглядит так: буква 'x', далее строка 'ab' один или более раз, потом буква 'x':");
addBr(aC("	".'$str'." = 'xabx xababx xaabbx';<br/>
".'$res'." = preg_replace('#x(ab)+x#', '!', ".'$str'.");"));
addBr(aC('echo $res').' = '. preg_replace('#x(ab)+x#', '!', 'xabx xababx xaabbx'));

addBr(rB('Задача'));
addBr("Дана строка:	" . '$str' . " = 'ab abab abab abababab abea'; " . "Напишите регулярку, которая найдет строки по шаблону: строка 'ab' повторяется 1 или более раз.");
$str = 'ab abab abab abababab abea';
$result = preg_replace('#(ab)+#', '!', $str);
addBr(aC("preg_replace('#(ab)#','!','ab abab abab abababab abea')") . ' = ' . $result);
hr();
addBr(rB('Экранировка спецсимволов в регулярках PHP'));
addBr("Предположим, что мы хотим сделать так, чтобы спецсимвол обозначал сам себя. Для этого его нужно экранировать с помощью обратного слеша. Давайте посмотрим на примерах.");
addBr(aC("preg_replace('#a\+x#', '!', 'a+x ax aax aaax');").' = '. preg_replace('#a\+x#', '!', 'a+x ax aax aaax'));
hr();


addBr(rB('Список специальных символов в регулярках в PHP'));
addBr("Если экранировать обычный символ - ничего страшного не случится - он все равно будет обозначать сам себя. Исключение - цифры, их нельзя экранировать.
Часто возникает сомнение, является ли данный символ специальным. Некоторые доходят до того, что экранируют все подозрительные символы подряд. Однако, это плохая практика (захламляет регулярку обратными слешами).<br/>
 ". rB('Являются спецсимволами: $ ^ . * + ? \ / {} [] () |').'<br/>'.
 rB('Не являются спецсимволами: @ : , '."' ". " ; - _ = < > % # ~ ` & !"));
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	" . '$str' . " = 'a.a aba aea'; " . "Напишите регулярку, которая найдет строку 'a.a', не захватив остальные.");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '2+3 223 2223'; " . "Напишите регулярку, которая найдет строку '2+3', не захватив остальные.");
addBr(aC("preg_replace('#2\+3#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#2\+3#', '!', '2+3 223 2223'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '23 2+3 2++3 2+++3 345 567'; " . "Напишите регулярку, которая найдет строки '2+3', '2++3', '2+++3', не захватив остальные (+ может быть любое количество).");
addBr(aC("preg_replace('#2\++3#', 'туть ', '23 2+3 2++3 2+++3 345 567');") . ' = ' . preg_replace('#2\++3#', 'туть ', '23 2+3 2++3 2+++3 345 567'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '23 2+3 2++3 2+++3 345 567'; " . "Напишите регулярку, которая найдет строки '23', '2+3', '2++3', '2+++3', не захватив остальные.");
addBr(aC("preg_replace('#2\+*3#', 'туть ', '23 2+3 2++3 2+++3 345 567');") . ' = ' . preg_replace('#2\+*3#', 'туть ', '23 2+3 2++3 2+++3 345 567'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '*+ *q+ *qq+ *qqq+ *qqq qqq+'; " . "Напишите регулярку, которая найдет строки '*q+', '*qq+', '*qqq+', не захватив остальные.");
addBr(aC("preg_replace('#\*q+\+#', 'туть ', '*+ *q+ *qq+ *qqq+ *qqq qqq+');") . ' = ' . preg_replace('#\*q+\+#', 'туть ', '*+ *q+ *qq+ *qqq+ *qqq qqq+'));

addBr('');
addBr("Дана строка:	" . '$str' . " = '[abc] {abc} abc (abc) [abc]'; " . "Напишите регулярку, которая найдет строки в квадратных скобках и заменят их на 'туть '.");
addBr(aC("preg_replace('#\[abc*\]#', 'туть ', '[abc] {abc} abc (abc) [abc]');") . ' = ' . preg_replace('#\[abc\]#', 'туть ', '[abc] {abc} abc (abc) [abc]'));
hr();


addBr(rB('Фигурные скобки в регулярных выражения PHP'));
addBr("Операторы +, *, ? хороши, однако, с их помощью нельзя указать конкретное число повторений. В этом случае вам на помощь придет оператор {}.
<br/>
<br/>
". rB('Работает он следующим образом:')." {5} - пять повторений, {2,5} - повторяется от двух до пяти (оба включительно), {2,} - повторяется два и более раз.");
addBr(aC("	" . '$str' . " = 'xx xax xaax xaaax';<br/>
" . '$res' . " = preg_replace('#xa{1,2}x#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' . preg_replace('#xa{1,2}x#', '!', 'xx xax xaax xaaax'));
addBr('');

addBr(rB('Задачи'));
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки 'abba', 'abbba', 'abbbba' и только их.");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{2,4}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{2,4}a#', 'туть ', 'aa aba abba abbba abbbba abbbbba'));

addBr('');
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается менее трех раз (включительно).");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{0,3}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{0,3}a#', 'туть ', 'aa aba abba abbba abbbba abbbbba'));

addBr('');
addBr("Дана строка:	" . '$str' . " = 'aa aba abba abbba abbbba abbbbba'; " . "Напишите регулярку, которая найдет строки вида 'aba', в которых 'b' встречается более четырех раз (включительно).");
addBr(aC("preg_replace('#a\.a#', '!', 'a.a aba aea');") . ' = ' . preg_replace('#a\.a#', '!', 'a.a aba aea'));
addBr(aC("preg_replace('#ab{4,}a#', 'туть ', ''aa aba abba abbba abbbba abbbbba'');") . ' = ' . preg_replace('#ab{4,}a#', rB('туть '), 'aa aba abba abbba abbbba abbbbba'));
hr();


addBr(rB('Ограничение жадности в регулярках в PHP'));
addBr("Регулярные выражения по умолчанию жадные. Это значит, что они захватывают максимальное возможное количество символов.");
addBr("Давайте посмотрим на примере. Пусть у нас есть вот такая строка:");
addBr(aC("	".'$str'." = 'aeeex zzz x kkk';"));
addBr("Пусть мы в этой строке хотим найти подстроку 'aeeex' по следующему шаблону: буква 'a', затем любой символ один или более раз, затем буква 'x'.");
addBr(aC('$res'." = preg_replace('#a.+x#', '!', ".'$str'.");"));
addBr("Мы ожидаем, что в переменную в результате запишется строка '! zzz x kkk'. Однако, это не так - в переменную попадает строка '! kkk'.
<br/>
Все дело в том, что наша регулярка ищет все символы от буквы 'a' до буквы 'x'. Но в нашей строке две буквы 'x'. Из-за жадности получается, что регулярка ищет до самого последнего икса, тем самым захватывая не то, что мы ожидали.
<br/>
Конечно, зачастую такое поведение нам и нужно. Но конкретно в этом случае мы бы хотели отменить жадность и сказать регулярке, чтобы она искала до первого икса.
<br/>
Чтобы ограничить жадность, нужно после оператора повторения поставить знак вопроса:");
addBr(aC('$res'." = preg_replace('#a.+?x#', '!', ".'$str'.");"));
addBr("Тогда мы получим изначально запланированный результат:");
echo(aC('echo $res').' = '. preg_replace('#a.+?x#', '!','aeeex zzz x kkk'));
hr();
addBr(rB("Жадность можно ограничивать всем операторам повторения, вот так: *?, ?? и {}?."));
hr();

addBr(rB('Задача'));
addBr("Дана строка:	" . '$str' . " = 'aba accca azzza wwwwa'; " . "Напишите регулярку, которая найдет все строки по краям которых стоят буквы 'a', и заменит каждую из них на '!'. Между буквами a может быть любой символ (кроме 'a').");
addBr(aC("preg_replace('#a.+?a#', 'туть ', 'aba accca azzza wwwwa');") . ' = ' . preg_replace('#a.+?a#', 'туть ', 'aba accca azzza wwwwa'));
hr();
addBr(rB('Группы символов в регулярных выражениях PHP'));
addBr('Существуют специальные команды, которые позволяют выбрать сразу целые группы символов. '.rB('Команда \d').' означает цифру от 0 до 9. '.rB('Команда \w').' обозначает цифру, латинскую букву или знак подчеркивания. '.rB('Команда \s').' обозначает пробел или пробельный символ: пробел, перевод строки, табуляцию. '.rB('Можно инвертировать значение команды').', написав большую букву: например, если '.rB('\d - цифра').', то '.rB('\D - не цифра').'.');

addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aa a1a a2a a3a a4a a5a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними одна цифра.");
$str = 'aa a1a a2a a3a a4a a5a aba aca';
addBr(aC('$str = ' . "'a1a a2a a3a a4a a5a aba aca';"));
$result = preg_replace('#a\da#', 'туть ', $str);
addBr(aC("preg_replace('#a\da#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aa a1a a22a a333a a4444a a55555a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр.");
$str = 'aa a1a a22a a333a a4444a a55555a aba aca';
addBr(aC('$str = ' . "'aa a1a a22a a333a a4444a a55555a aba aca';"));
$result = preg_replace('#a\d+?a#', 'туть ', $str);
addBr(aC("preg_replace('#a\d+?a#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aa a1a a22a a333a a4444a a55555a aba aca'; " . "Напишите регулярку, которая найдет строки, в которых по краям стоят буквы 'a', а между ними любое количество цифр (в том числе и ноль цифр, то есть строка 'aa').");
$str = 'aa a1a a22a a333a a4444a a55555a aba aca';
addBr(aC('$str = ' . "'aa a1a a22a a333a a4444a a55555a aba aca';"));
$result = preg_replace('#a\d*?a#', 'туть ', $str);
addBr(aC("preg_replace('#a\d*?a#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'avb a1b a2b a3b a4b a5b abb acb'; " . "Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не число.");
$str = 'avb a1b a2b a3b a4b a5b abb acb';
addBr(aC('$str = ' . "'avb a1b a2b a3b a4b a5b abb acb';"));
$result = preg_replace('#a\Db#', 'туть ', $str);
addBr(aC("preg_replace('#a\Db#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'ave a#b a2b a\$b a4b a5b a-b acb'; " . "Напишите регулярку, которая найдет строки следующего вида: по краям стоят буквы 'a' и 'b', а между ними - не буква и не цифра.");
$str = 'ave a#b a2b a$b a4b a5b a-b acb';
addBr(aC('$str = ' . "'ave a#b a2b a\$b a4b a5b a-b acb';"));
$result = preg_replace('#a\Wb#', 'туть ', $str);
addBr(aC("preg_replace('#a\Wb#','туть ',$str)") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'ave a#a a2a a\$a a4a a5a a-a aca'; " . "Напишите регулярку, которая заменит все пробелы на '!'.");
$str = 'ave a#b a2b a$b a4b a5b a-b acb';
addBr(aC('$str = ' . "'ave a#b a2b a\$b a4b a5b a-b acb';"));
$result = preg_replace('#\s#', '!', $str);
addBr(aC("preg_replace('#\s#','!',$str)") . ' = ' . $result);
hr();


addBr(rB('Наборы символов в регулярных выражениях PHP'));
addBr("Группы символов ".rB('\d'). " и " . rB('\w')." не очень гибкие. Даже такая простая задача, как найти все буквы, но не цифры - не может быть решена ими. Для таких задач следует использовать квадратные скобки, представляющие собой операцию ИЛИ.<br/>
Квадратные скобки заменяют собой один символ, любой из перечисленных внутри. К примеру, вот так: #x[abc]x# - мы говорим, что по краям должны стоять буквы икс, а внутри - один символ: или 'a', или 'b', или 'c'.<br/>
После квадратных скобок можно писать операторы повторения. К примеру, вот так: ".rB('#x[abc]+x#'). " - мы говорим, что внутри иксов может быть любое количество символов 'a', 'b' и 'c' - в любых комбинациях.<br/>
Можно не только перечислять символы, но создавать группы символов, записывая между двумя символами дефис. К примеру, вот так: " . rB('#[a-d]#')." - мы получаем все символы от 'a' до 'd'.");
// Примеры: 
// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифра от 1 до 9:
// $str = 'xax x1x x3x x5x x@x';
// $res = preg_replace('#x[a-z1-9]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! ! x@x'

// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или буква от 'A' до 'Z':
// $str = 'xax xBx xcx x5x x@x';
// $res = preg_replace('#x[a-zA-Z]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! x5x x@x'

// В данном примере шаблон поиска выглядит так: между иксами любая буква от 'a' до 'z' или цифры 1, 2:
// $str = 'xax xbx x1x x2x x3x';
// $res = preg_replace('#x[a-z12]x#', '!', $str);
// В результате в переменную запишется следующее: '! ! ! ! x3x'
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aba aea aca aza axa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква 'b', 'e' или 'x'.");
$str = 'aba aea aca aza axa';
addBr(aC('$str = ' . "'aba aea aca aza axa';"));
$result = preg_replace('#a[bex]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[bex]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'a1a a3a a7a a9a aba'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - цифра от 3-х до 6-ти.");
$str = 'a1a a3a a7a a9a aba';
addBr(aC('$str = ' . "'a1a a3a a7a a9a aba';"));
$result = preg_replace('#a[3-6]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[3-6]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aba aea afa aha aga'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до g.");
$str = 'aba aea afa aha aga';
addBr(aC('$str = ' . "'aba aea afa aha aga';"));
$result = preg_replace('#a[a-g]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-g]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aba aea afa aha aga'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от j до z.");
$str = 'aba aea afa aha aga';
addBr(aC('$str = ' . "'aba aea afa aha aga';"));
$result = preg_replace('#a[a-fj-z]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-fj-z]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAa aea aEa aJa a3a'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - буква от a до f и от A до D.");
$str = 'aAa aea aEa aJa a3a';
addBr(aC('$str = ' . "'aAa aea aEa aJa a3a';"));
$result = preg_replace('#a[a-fA-D]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-fA-D]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-z]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-z]+a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие и большие латинские буквы, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-zA-Z]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-zA-Z]+a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'aAXa aeffa aGha aza ax23a a3sSa'; " . "Напишите регулярку, которая найдет по следующему шаблону: по краям стоят буквы 'a', а между ними - маленькие латинские буквы и цифры, не затронув остальных.");
$str = 'aAXa aeffa aGha aza ax23a a3sSa';
addBr(aC('$str = ' . "'aAXa aeffa aGha aza ax23a a3sSa';"));
$result = preg_replace('#a[a-z0-9]+a#', 'туть ', $str);
addBr(aC("preg_replace('#a[a-z0-9]+a#','туть ','$str')") . ' = ' . $result);
// addBr('');
hr();


addBr(rB('Инвертирование наборов символов в регулярках'));
addBr("С помощью шляпки ^ в начале квадратных скобок можно инвертировать желаемое. То есть, если, к примеру, команда ".rB('[ab]'). " ищет букву 'a' или 'b', то команда " . rB('[^ab]')." будет искать все символы, кроме 'a' и 'b'.");

addBr('');
addBr(rB('Практические задачи'));
addBr("Напишите регулярку, которая найдет строки по шаблону: цифра '1', затем символ не 'e' и не 'x', цифра '2'.");
$str = '1e2 1ex2 132 1ab abc4';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4';"));
$result = preg_replace('#1[^ex]2#', 'туть ', $str);
addBr(aC("preg_replace('#1[^ex]2#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ цифра от 2 до 7, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^2-7]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^2-7]z#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ большая латинская буква от 1 и более раз, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^A-Z+]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^A-Z+]z#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем не большая и не маленькая латинская буква и не цифра от 1 до 5 от 1 и более раз, буква 'z'.");
$str = '1e2 1ex2 132 1ab abc4 x9z';
addBr(aC('$str = ' . "'1e2 1ex2 132 1ab abc4 x9z';"));
$result = preg_replace('#x[^A-Za-z1-5+]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^A-Za-z1-5+]z#','туть ','$str')") . ' = ' . $result);
hr();


addBr(rB('Особенности кириллицы в регулярках PHP'));
addBr("Кириллические символы не входят в группу \w. Для их получения нужно использовать группу в квадратных скобках, вот так: [а-я]. Но даже с этой группой есть проблема - сюда не войдет буква 'ё'. Для ее включения нужно сделать вот так: " . rB('[а-яё].')

.rB('Для корректной работы кириллицы в регулярке необходимо поставить модификатор u:'));
addBr("");
addBr(aC("	".'$str'." = 'яяя ййй ёёё';<br/>
	".'$res'." = preg_replace('#[а-яё]#u', '!', ".'$str'.");"));

addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'wйw wяw wёw wqw'; " . "Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'w', а между ними - буква кириллицы.");
$str = 'wйw wяw wёw wqw';
addBr(aC('$str = ' . "'wйw wяw wёw wqw';"));
$result = preg_replace('#w[а-яё]w#u', 'туть ', $str);
addBr(aC("preg_replace('#w[а-яё]w#u','туть ','$str')") . ' = ' . $result);

addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ'; " . "Напишите регулярку, которая найдет все слова по шаблону: любая кириллическая буква любое количество раз.");
$str = 'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';
addBr(aC('$str = ' . "'ааа ббб ёёё ззз ййй ААА БББ ЁЁЁ ЗЗЗ ЙЙЙ';"));
$result = preg_replace('#[а-яёА-ЯЁ]+#u', 'туть ', $str);
addBr(aC("preg_replace('#[а-яёА-ЯЁ]+#u','туть ','$str')") . ' = ' . $result);
hr();

addBr(rB('Спецсимволы внутри квадратных скобок в PHP'));
addBr("Спецсимволы внутри [] становятся обычными символами. Это значит, что ".rB('их не надо экранировать обратным слешем.'));
// Пример: В данном примере шаблон поиска выглядит так: между иксами любая буква 'a', 'b', 'c', либо точка:
// $str = 'xax xbx xcx xdx x.x x@x';
// $res = preg_replace('#x[abc.]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! xdx ! x@x'

// Пример: В данном примере шаблон поиска выглядит так: между иксами любая маленькая латинская буква или точка:
// $str = 'xax xbx xcx x@x';
// $res = preg_replace('#x[a-z.]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! x@x'
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aba aea aca aza axa a.a a+a a*a'; " . "Напишите регулярку, которая найдет строки 'a.a', 'a+a', 'a*a', не затронув остальных.");
$str = 'aba aea aca aza axa a.a a+a a*a';
addBr(aC('$str = ' . "'aba aea aca aza axa a.a a+a a*a';"));
$result = preg_replace('#.[+.*]a#', 'туть ', $str);
addBr(aC("preg_replace('#a[+.*]a#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'xaz x.z x3z x@z x\$z xrz'; " . "Напишите регулярку, которая найдет строки по шаблону: буква 'x', затем НЕ точка, НЕ собака, и НЕ доллар, а потом буква 'z'.");
$str = 'xaz x.z x3z x@z x$z xrz';
addBr(aC('$str = ' . "'xaz x.z x3z x@z x\$z xrz';"));
$result = preg_replace('#x[^.@$]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[^.@$]z#','туть ','$str')") . ' = ' . $result);
hr();

addBr(rB('Группы символов внутри квадратных скобок PHP'));
addBr("Группы символов \d, \D, \w, \W, \s, \S внутри [] будут обозначать именно группы, то есть по-прежнему будут командами.");
// Пример: В данном примере шаблон поиска выглядит так: между иксами любая цифра, либо буква от 'a' до 'f':
// $str = 'xax xbx x1x x2x xhx x@x';
// $res = preg_replace('#x[\da-f]x#', '!', $str);
// В результате в переменную запишется следующее:'! ! ! ! xhx x@x'

// Пример: В данном примере шаблон поиска выглядит так: буква 'x', затем не цифра, не точка, и не маленькая латинская буква, затем буква 'z':
// $str = 'xaz x1z xAz x.z x@z';
// $res = preg_replace('#x[^\d.a-z]z#', '!', $str);
// В результате в переменную запишется следующее:'xaz x1z ! x.z !'

addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aba a11a a.za a..a a.a a+2a a*a'; " . "Напишите регулярку, которая найдет строки по шаблону: цифра или точка от 1 и более раз.");
$str = 'aba a11a a.za a..a a.a a+2a a*a';
addBr(aC('$str = ' . "'aba a11a a.za a..a a.a a+2a a*a';"));
$result = preg_replace('#[\d.]#', 'туть ', $str);
addBr(aC("preg_replace('#[\d.]+#','туть ','$str')") . ' = ' . $result);
hr();


addBr(rB('Исключения внутри наборов в регулярках в регулярках PHP'));
addBr("Вы уже знаете, что спецсимволы внутри [] становятся обычными символами. Есть, однако, исключения: если вам нужны квадратные скобки как символы, то их нужно экранировать обратным слешем.
Для примера в следующем коде шаблон поиска выглядит так: между иксами стоит квадратная скобка:");
addBr(aC('$str'." = 'x]x xax x[x x1x';<br/>"
.'$res'." = preg_replace('#x[/[/]]x#', '!', ".'$str'.");"));
addBr('В результате в переменную запишется следующее:'.aC("'! xax ! x1x'"));
addBr("");
$str = 'x]x xax x[x x1x';
$res = preg_replace('#x[\[\]]x#', '!',$str);
echo $res;

addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'x[]z x{}z x.z x()z' " . "Напишите регулярку, которая найдет все слова по шаблону: буква 'x', затем любое количество любых скобок, затем буква 'z'.");
$str = 'x[]z x{}z x.z x()z';
addBr(aC('$str = ' . "'x[]z x{}z x.z x()z';"));
$result = preg_replace('#x[\[\]{}()]+z#', 'туть ', $str);
addBr(aC("preg_replace('#x[\[\]{}()]+z#','туть ','$str')") . ' = ' . $result);
addBr('');
addBr("Дана строка:	" . '$str' . " = '[abc] {abc} abc (abc) [abc]' " . "Напишите регулярку, которая найдет строки в любых скобках и заменят их на 'туть'.");
$str = '[abc] {abc} abc (abc) [abc]';
addBr(aC('$str = ' . "'[abc] {abc} abc (abc) [abc]';"));
$result = preg_replace('#[{(\[][a-z]+[})\]]#', 'туть ', $str);
addBr(aC("preg_replace('#[{(\[][a-z]+[})\]]#','туть ','$str')") . ' = ' . $result);
hr();
addBr(rB('Символ шляпки внутри наборов в регулярках PHP'));
addBr("Как вы знаете, шляпка внутри [] делает отрицание, будучи написанной в начале скобок. Значит, она является спецсимволом внутри этих скобок. Чтобы получить шляпку как символ, нужно или заэкранировать ее, или убрать с первого места.");
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = '^xx axx ^zz bkk @ss' " . "Напишите регулярку, которая найдет строки по шаблону: шляпка или собака, а затем две латинских буквы.");
$str = '^xx axx ^zz bkk @ss';
addBr(aC('$str = ' . "'^xx axx ^zz bkk @ss';"));
$result = preg_replace('#[\^@][a-z]{2}#', 'туть ', $str);
addBr(aC("preg_replace('#[\^@][]a-z]{2}#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . "Напишите регулярку, которая найдет строки по шаблону: НЕ шляпка, а затем две латинских буквы.");
$str = '^xx axx ^zz bkk';
addBr(aC('$str = ' . "'^xx axx ^zz bkk';"));
$result = preg_replace('#[^\^\s][a-z]{2}#', ' туть ', $str);
addBr(aC("preg_replace('#[^\^\s][]a-z]{2}#',' туть ','$str')") . ' = ' . $result);
hr();


addBr(rB('Дефис внутри наборов в регулярках PHP'));
addBr("Дефис - ".rB('тоже спецсимвол внутри [] (а вот снаружи - нет)').". Если вам нужен сам дефис как символ - то поставьте его там, где он не будет воспринят как разделитель группы.<br/>
Почему это важно: вы можете сделать группу символов, сами не заметив этого. К примеру, вот так - [:-@] - вы думаете, что выбираете двоеточие, дефис и собаку, а на самом деле получается группа символов между : и @. В эту группу входят следующие символы: :, ;, ?, <, =, >.<br/>
Откуда они взялись? Из таблицы ASCII - двоеточие имеет номер меньше, чем собака - и получается группа. То есть все группы получаются по таблице ASCII (при желании этим можно пользоваться).<br/>
Как с этим бороться: поставьте символ дефиса там, где он точно не будет воспринят как символ группы, например, в начале или в конце (то есть после [ или перед ]).<br/>
Можно также заэкранировать дефис - тогда он будет обозначать сам себя независимо от позиции. Например, вместо [:-@] написать [:\-@] - и группы уже не будет, а будут три символа - двоеточие, дефис и собака @.");
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'xaz xBz xcz x-z x@z' " . "Найдите все строки по следующему шаблону: буква 'x', большая или маленькая буква или дефис, буква 'z'.");
$str = 'xaz xBz xcz x-z x@z';
addBr(aC('$str = ' . "'xaz xBz xcz x-z x@z';"));
$result = preg_replace('#x[A-Za-z-]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[A-Za-z-]z#','туть ','$str')") . ' = ' . $result);
addBr('');

addBr("Дана строка:	" . '$str' . " = 'xaz x\$z x-z xcz x+z x%z x*z' " . "Найдите все строки по следующему шаблону: буква 'x', затем или доллар, или дефис или плюс, потом буква 'z'.");
$str = 'xaz x$z x-z xcz x+z x%z x*z';
addBr(aC('$str = ' . "'xaz x\$z x-z xcz x+z x%z x*z';"));
$result = preg_replace('#x[$+-]z#', 'туть ', $str);
addBr(aC("preg_replace('#x[$+-]z#','туть ','$str')") . ' = ' . $result);
addBr('');
hr();


addBr(rB('Начало и конец строки в регулярках PHP'));
addBr("Существуют специальные символы, которые обозначают начало ^ или конец строки $. Давайте посмотрим их работу на примерах.");

addBr(rB('Пример 1')."<br/>
В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в начале строки:"); 
$str = 'aaa aaa aaa';
addBr(aC('$str'. " = 'aaa aaa aaa'"));
addBr(aC('$res'." = preg_replace('#^aaa#', '!', ".'$str'.");"));
addBr(aC('echo $res').' = '.  preg_replace('#^aaa#', '!', 'aaa aaa aaa'));

addBr(rB('Пример 2'). "<br/>
В данном примере шаблон поиска такой: заменить 'aaa' на '!' только, если оно стоит в конце строки:"); 
$str = 'aaa aaa aaa';
addBr(aC('$str'. " = 'aaa aaa aaa'"));
addBr(aC('$res'." = preg_replace('#aaa$#', '!', ".'$str'.");"));
addBr(aC('echo $res').' = '. preg_replace('#aaa$#', '!', 'aaa aaa aaa'));

addBr(rB('Пример 3'). "<br/>
Когда в начале регулярки стоит ^, а в конце - $, то таким образом мы проверяем всю строку целиком на соответствие регулярке.<br/>
В следующем примере шаблон поиска такой: буква 'a' повторяется один или более раз, заменить всю строку на '!' только она состоит из одних букв 'a'."); 
$str = 'aaa';
addBr(aC('$str'. " = 'aaa'"));
addBr(aC('$res'." = preg_replace('#^a+$#', '!', ".'$str'.");"));
addBr(aC('echo $res').' = '. preg_replace('#^a+$#', '!', 'aaa'));

addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'abc def xyz' " . "Напишите регулярку, которая найдет первую подстроку из букв.");
$str = 'abc def xyz';
addBr(aC('$str = ' . "'abc def xyz';"));
$result = preg_replace('#^[a-z]+#', 'туть ', $str);
addBr(aC("preg_replace('#^[a-z]+#','туть ','$str')") . ' = ' . $result);
addBr('');
addBr("Дана строка:	" . '$str' . " = 'abc def xyz' " . "Напишите регулярку, которая найдет последнюю подстроку из букв.");
$str = 'abc def xyz';
addBr(aC('$str = ' . "'abc def xyz';"));
$result = preg_replace('#[a-z]+$#', 'туть ', $str);
addBr(aC("preg_replace('#[a-z]+$#','туть ','$str')") . ' = ' . $result);
hr();


addBr(rB('Конец или начало слова в регулярках PHP'). "<br/>
Команда ".rB('\b'). " обозначает начало или конец слова, а " . rB('\B').", соответственно, - не начало и не конец слова. Что такое слово? На первый взгляд кажется, что это нечто, ограниченное пробелами, но это не совсем так.<br/>
Посмотрите на следующую строку: 'мама мыла раму'. Подстрока 'мыла' - это слово (по обоим краям пробелы), однако и 'мама', и 'раму' тоже слова, которые стоят в начале и в конце строки.<br/>
Давайте посмотрим на практическое применение данной команды.<br/>
В следующем примере шаблон поиска такой: начало слова, маленькие латинские буквы один или более раз, конец слова. Таким образом, регулярка найдет все слова и заменит их на '!':"); 
addBr(aC("echo preg_replace('#\b[a-z]+\b#', '!', 'axx bxa xxa exb');")." = ". preg_replace('#\b[a-z]+\b#', '!', 'axx bxa xxa exb'));
addBr(aC("echo preg_replace('#\b[a-b]#', '!', 'axx bxa xxa exb');")." = ". preg_replace('#\b[a-b]#', '!', 'axx bxa xxa exb'));
addBr(aC("echo preg_replace('#[a-b]\b#', '!', 'axx bxa xxa exb');")." = ". preg_replace('#[a-b]\b#', '!', 'axx bxa xxa exb'));
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aaa xaa aax xbb aaa' " . "Напишите регулярку, которая найдет строки по шаблону: буква 'x' в начале слова.");
$str = 'aaa xaa aax xbb aaa';
addBr(aC('$str = ' . "'aaa xaa aax xbb aaa';"));
$result = preg_replace('#\bx[a-z]+#', 'туть ', $str);
addBr(aC("preg_replace('#\bx[a-z]+#','туть ','$str')") . ' = ' . $result);

addBr('');
addBr("Дана строка:	" . '$str' . " = 'aaa xaa aax xbb aaa' " . "Напишите регулярку, которая найдет строки по шаблону: буква 'x' в конце слова.");
$str = 'aaa xaa aax xbb aaa';
addBr(aC('$str = ' . "'aaa xaa aax xbb aaa';"));
$result = preg_replace('#[a-z]+x\b#', 'туть ', $str);
addBr(aC("preg_replace('#[a-z]+x\b#','туть ','$str')") . ' = ' . $result);
hr();


addBr(rB("Команда 'или' в регулярных выражениях PHP") . "<br/>
В данном уроке мы разберем ".rB(' команду |').", которая представляет собой более мощный вариант ИЛИ по сравнению с ".rB(' командой []').". Данная команда позволяет разделить регулярку на несколько частей. При этом искомое может попасть либо под одну часть регулярки, либо под другую. Давайте посмотрим на примерах.");


addBr(rB('Пример 1') . "<br/>В данном примере шаблон поиска такой: три буквы 'a' или три буквы 'b':");
$str = 'aaa bbb abb';
addBr(aC('$str' . " = 'aaa bbb abb'"));
addBr(aC('$res' . " = preg_replace('#a{3}|b{3}#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' .  preg_replace('#a{3}|b{3}#', '!', $str));

addBr(rB('Пример 2') . "<br/>В данном примере шаблон поиска такой: три буквы 'a' или от 1 и более букв 'b':");
$str = 'aaa bbb bbbb bbbbb axx';
addBr(aC('$str' . " = 'aaa bbb bbbb bbbbb axx'"));
addBr(aC('$res' . " = preg_replace('#a{3}|b+#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' .  preg_replace('#a{3}|b+#', '!', $str));

addBr(rB('Пример 3') . "<br/>В данном примере шаблон поиска такой: одна или более буквы или три цифры:");
$str = 'a ab abc 1 12 123';
addBr(aC('$str' . " = 'a ab abc 1 12 123'"));
addBr(aC('$res' . " = preg_replace('#[a-z]+|\d{3}#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' .  preg_replace('#[a-z]+|\d{3}#', '!', $str));

addBr(rB('Пример 4') . "<br/>Вертикальная черта может делить регулярку не на две части, а на любое количество частей:");
$str = 'aaa bbb ccc ddd';
addBr(aC('$str' . " = 'aaa bbb ccc ddd'"));
addBr(aC('$res' . " = preg_replace('#a+|b+|c+#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' .  preg_replace('#a+|b+|c+#', '!', $str));

addBr(rB('Пример 5') . "<br/>Если вертикальная черта стоит внутри круглых скобок, то 'или' работает только внутри этих скобок. Для примера давайте найдем строки по следующему шаблону: в начале стоит или 'a', или 'b' один или более раз, а потом две буквы 'x':");
$str = 'axx aax bxx bbxx exx';
addBr(aC('$str' . " = 'axx aax bxx bbxx exx'"));
addBr(aC('$res' . " = preg_replace('#(a|b+)xx#', '!', " . '$str' . ");"));
addBr(aC('echo $res') . ' = ' .  preg_replace('#(a|b+)xx#', '!', $str));
addBr('');
addBr(rB('Практические задачи'));
addBr("Дана строка:	" . '$str' . " = 'aeeea aeea aea axa axxa axxxa' " . "Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' любое количество раз или буква 'x' любое количество раз.");
$str = 'aeeea aeea aea aa axa axxa axxxa';
addBr(aC('$str = ' . "'aeeea aeea aea aa axa axxa axxxa';"));
$result = preg_replace('#a(e+|x+)a#', 'туть ', $str);
addBr(aC("preg_replace('#a(e+|x+)a#','туть ','$str')") . ' = ' . $result);
addBr('');
addBr("Дана строка:	" . '$str' . " = 'aeeea aeea aea axa axxa axxxa' " . "Напишите регулярку, которая найдет строки по шаблону: по краям стоят буквы 'a', а между ними - или буква 'e' два раза или буква 'x' любое количество раз.");
$str = 'aeeea aeea aea aa axa axxa axxxa';
addBr(aC('$str = ' . "'aeeea aeea aea aa axa axxa axxxa';"));
$result = preg_replace('#a(e{2}|x+)a#', 'туть ', $str);
addBr(aC("preg_replace('#a(e{2}|x+)a#','туть ','$str')") . ' = ' . $result);
addBr('');
hr();


addBr(rB("Ограничители регулярок в PHP") . "<br/> В качестве ограничителей могут выступать не только #, но и любые другие символы (только не буквы и не цифры). К примеру, возьмем в качестве ограничителей символы амперсандов:");
addBr(aC("echo preg_replace('&а+&', '!', 'строка');"));
addBr('Если используются скобки, тогда левый ограничитель - это открывающая скобка, а правый - закрывающая:');
addBr(aC("echo preg_replace('(а+)', '!', 'строка');"));

addBr(rB('Задача'));
addBr("Используйте в качестве ограничителей символ тильды ~");
$str = 'aeeea aeea aea aa axa axxa axxxa';
addBr(aC('$str = ' . "'aeeea aeea aea aa axa axxa axxxa';"));
$result = preg_replace('~a(e+|x+)a~', 'туть ', $str);
addBr(aC("preg_replace('~a(e+|x+)a~','туть ','$str')") . ' = ' . $result);
hr();


addBr(rB("Экранировка ограничителей в PHP") . "<br/> Если символ не является специальным, то, когда вы используете его в качестве ограничителя, его нужно будет экранировать в самой регулярке. Посмотрим на примере.<br/>
Пусть у нас в качестве ограничителей выступают решетки, а внутри регулярки мы ищем символ амперсанда. Так как амперсанд не является спецсимволовм, то мы его не экранируем:");
addBr(aC("echo preg_replace('#a&b#', '!', 'a&b') = "). preg_replace('#a&b#', '!', 'a&b'));
addBr('Пусть теперь ограничители - амперсанды и внутри регулярки нам также нужен амперсанд. В таком случае амперсанд внутри приходится экранировать, иначе это вызовет ошибку PHP:');
addBr(aC("echo preg_replace('&a\&b&', '!', 'a&b') = "). preg_replace('&a\&b&', '!', 'a&b'));

addBr(rB('Задача'));
addBr("Исправьте ошибку, допущенную в следующем коде: ".aC("echo preg_replace('#a#b#', '!', 'a#b');"));
// addBr(aC('$str = ' . "'aeeea aeea aea aa axa axxa axxxa';"));
// $result = preg_replace('~a(e+|x+)a~', 'туть ', $str);
addBr(aC("echo preg_replace('#a\#b#', '!', 'a#b');") . ' = ' . preg_replace('#a\#b#', '!', 'a#b'));
hr();


addBr(rB("Проблема обратного слеша в PHP") . "<br/> Обратный слеш является спецсимволом PHP. Это значит, что в строке, если мы хотим, чтобы слеш обозначал сам себя, мы должны его удвоить:");
$str = '\\ \\\\ \\\\\\';
addBr(aC('$str = ' . "'\\\\ \\\\\\\\ \\\\\\\\\\\\\\'"));
addBr(aC("echo ".'$str') . ' = ' . $str);
addBr('Обратный слеш также является и спецсимволом регулярок. Это значит, что внутри регулярки, чтобы слеш обозначал сам себя, его нужно написать аж '.rB('четыре раза:'));
addBr(aC("echo preg_replace('#\\\\\\\\#', '!', '\\ \\\\ \\\\\\')").' = ' . preg_replace('#\\\\#', '!', '\\ \\\\ \\\\\\'));
addBr('Давайте теперь напишем регулярку, в которой шаблон поиска будет такой: обратный слеш один или более раз. В таком случае мы напишем оператор + аж для 4 символов перед ним без группировки:');
addBr(ac("echo preg_replace('#\\\\\\\\+#', '!', '\\ \\\\ \\\\\\')").' = ' . preg_replace('#\\\\+#', '!', '\\ \\\\ \\\\\\'));
hr();



addBr(rB("Проверка строки с помощью регулярки на PHP") . "<br/> Поиском и заменой возможности регулярок далеко не исчерпаны. Существует также функция ".rB('preg_match' . rI(' которая проверяет, есть ли в строке совпадение с регуляркой')).". Первым параметром функция принимает регулярное выражение, а вторым - строку для поиска.<br/>
При этом, если совпадений будет много, - функция найдет только первое и закончит свою работу. Поэтому функция выводит либо 1, либо 0 и используется для ответа на вопрос 'есть искомое в строке или нет'. Вернет один - значит есть (а сколько раз - неясно), вернет ноль - значит нет.<br/>
Давайте посмотрим на примерах. Проверим, есть ли в строке подстрока, состоящая из букв 'a', повторенных один или более раз:");
addBr(aC("echo preg_match('#a+#', 'eee aaa bbb')").' = '. preg_match('#a+#', 'eee aaa bbb'));
addBr('А теперь в нашей строке нет искомого, и функция выведет 0:');
addBr(aC("echo preg_match('#a+#', 'eee ccc bbb')").' = '. preg_match('#a+#', 'eee ccc bbb'));
addBr("");
addBr(rB('Задачи'));
addBr("Определите, есть ли в строке 3 цифры подряд.");
addBr(aC("echo preg_match('#\d{3}#', '1 22 333 444')") . ' = ' . preg_match('#\d{3}#', '1 22 333 444'));
addBr('');
addBr("Определите, начинается ли переданная строка с http.");
addBr(aC("echo preg_match('#^http#', 'https://code.mu')") . ' = ' . preg_match('#^http#', 'https://code.mu'));
addBr(aC("echo preg_match('#^https#', 'http://code.mu')") . ' = ' . preg_match('#^https#', 'http://code.mu'));
addBr(aC("echo preg_match('#^http#', 'www.code.mu')") . ' = ' . preg_match('#^http#', 'www.code.mu'));
addBr('');
addBr("Определите, начинается ли переданная строка с http или с https.");
addBr(aC("echo preg_match('#^http|^https#', 'http://code.mu')") . ' = ' . preg_match('#^http|^https#', 'http://code.mu'));
addBr(aC("echo preg_match('#^http|^https#', 'https://code.mu')") . ' = ' . preg_match('#^http|^https#', 'https://code.mu'));
addBr(aC("echo preg_match('#^http|^https#', 'www.code.mu')") . ' = ' . preg_match('#^http|^https#', 'www.code.mu'));
addBr('');
addBr("Определите, заканчивается ли переданная строка расширением txt, html или php.");
addBr(aC("echo preg_match('#txt|html|php$#', 'smile.jpg')") . ' = ' . preg_match('#txt|html|php$#', 'smile.jpg'));
addBr(aC("echo preg_match('#txt|html|php$#', 'smile.txt')") . ' = ' . preg_match('#txt|html|php$#', 'smile.txt'));
addBr(aC("echo preg_match('#txt|html|php$#', 'smile.php')") . ' = ' . preg_match('#txt|html|php$#', 'smile.php'));
addBr(aC("echo preg_match('#txt|html|php$#', 'smile.html')") . ' = ' . preg_match('#txt|html|php$#', 'smile.html'));
addBr('');
addBr("Определите, заканчивается ли переданная строка расширением jpg или jpeg.");
addBr(aC("echo preg_match('#jpg|jpeg$#', 'smile.jpg')") . ' = ' . preg_match('#jpg|jpeg$#', 'smile.jpg'));
addBr(aC("echo preg_match('#jpg|jpeg$#', 'smile.jpeg')") . ' = ' . preg_match('#jpg|jpeg$#', 'smile.jpeg'));
addBr(aC("echo preg_match('#jpg|jpeg$#', 'smile.png')") . ' = ' . preg_match('#jpg|jpeg$#', 'smile.png'));
hr();



addBr(rB('Автоматическое тестирование регулярок в PHP'));
addBr("Давайте напишем код, который позволит нам удобно тестировать написанные нами регулярки сразу на нескольких строках.<br/>
Пусть наша регулярка для тестов хранится в следующей переменной:");
addBr(aC('$reg'." = '#\d{3,}#';"));
addBr("Давайте сделаем массив строк для проверок:");
addBr(aC('$arr[]'." = 'aaa 123 bbb';<br/>
".'$arr[]'." = 'aaa 12345 bbb';<br/>
".'$arr[]'." = 'aaa 12x bbb';<br/>
".'$arr[]'." = 'aaa 12 bbb';"));
addBr("Переберем этот массив циклом, проверяя каждый элемент нашей регуляркой:");
addBr(aC("foreach (".'$arr'." as ".'$str'.") {<br/>
echo ".'$str'." . ' ' . preg_match(".'$reg'.", ".'$str'. ") . ".htmlspecialchars('<br/>').";
<br/>}"));
addBr("Соберем весь код вместе и получим удобную заготовку для тестирования регулярок:");
addBr(aC("".'$reg'."   = '#\d{3,}#'; // ваша регулярка<br>

".'$arr'."[] = 'aaa 123 bbb';   // 1<br>
".'$arr'."[] = 'aaa 12345 bbb'; // 1<br>
".'$arr'."[] = 'aaa 12x bbb';   // 0<br>
".'$arr'."[] = 'aaa 12 bbb';    // 0<br>

foreach (".'$arr'." as ".'$str'.") {<br>
echo ".'$str'." . ' ' . preg_match(".'$reg'.", ".'$str'.") . '<br>';
	}"));
	addBr("");
	addBr("Пусть вам нужно проверить, что в строке есть дробное число. Используя предложенный скрипт, проверьте вашу регулярку на различных строках.");
	addBr(aC("
".'$reg'." = '#\d+\.\d+#';<br/>
".'$arrNum[]'."=7.62;<br/>
".'$arrNum[]'."=5.45;<br/>
".'$arrNum[]'."=5.56;<br/>
".'$arrNum[]'."=12.4;<br/>
".'$arrNum[]'."=155;<br/>
foreach(".'$arrNum'." as ".'$elem'."){<br/>
echo ".'$elem'.".(preg_match(".'$reg'.", ((String)".'$elem'."))?' есть дробь':' нет дроби')".htmlspecialchars('<br/>').";<br/>
}"));
$reg = '#\d+\.\d+#';
$arrNum[]=7.62;
$arrNum[]=5.45;
$arrNum[]=5.56;
$arrNum[]=12.4;
$arrNum[]=155;
foreach($arrNum as $elem){
	echo $elem.(preg_match($reg, ((String)$elem))?' есть дробь':' нет дроби').'<br/>';
};
hr();



addBr(rB('Проверка всей строки через регулярки в PHP'));
addBr("Часто preg_match используется для проверки на соответствие регулярному выражению всей строки. В таком случае в начале регулярки следует поставить шляпку ^, а в конце - доллар $. Этим мы говорим, что под шаблон должна попасть вся строка.<br/>
Давайте для примера узнаем, состоит ли строка целиком из букв 'a', или нет:");
addBr(aC("echo preg_match('#^a+$#', 'aaaa');").' = '.preg_match('#^a+$#', 'aaaa'));
addBr(aC("echo preg_match('#^a+$#', 'aaab');").' = '.preg_match('#^a+$#', 'aaab'));
addBr('');
addBr(rB('Задачи'));
addBr("Определите, является ли переданная строка является доменом. Используйте для тестов следующие строки:");
$arr[] = 'site.ru';          // +
$arr[] = 'site.com';         // +
$arr[] = 'my-site.com';      // +
$arr[] = 'my-cool-site.com'; // +
$arr[] = 'my_site.com';      // +
$arr[] = 'site123.com';      // +
$arr[] = 'site.travel';      // +
$arr[] = 'si$te.com';        // -
$arr[] = 'site.r';           // -
$reg = '#[a-z0-9-]{3,}\.[a-z]{2,}#';
foreach($arr as $elem){
	echo $elem.(preg_match($reg, ((String)$elem))?' домен':' недомен').'<br/>';
};

addBr('');
addBr("Определите, является ли переданная строка является емейлом. Используйте для тестов следующие строки:");
$arr = [];

$arr[] = 'addr@mail.ru';    // +
$arr[] = 'addr123@mail.ru'; // +
$arr[] = 'my-addr@mail.ru'; // +
$arr[] = 'my_addr@mail.ru'; // +
$arr[] = 'addr@site.ru';    // +
$arr[] = 'addr.ru';         // -
$arr[] = 'addr@.ru';        // -
$arr[] = 'my@addr@mail.ru'; // -
$reg = '#^[\w_-]{2,}\@{1}\w+\.ru$#';
foreach($arr as $elem){
	echo $elem.(preg_match($reg, ((String)$elem))?' mail':' не email').'<br/>';
};
hr();



addBr('Карманы при поиске через регулярки на PHP');
addBr(aC("Пусть у нас есть некоторая строка, содержащая домен:"));
addBr("Давайте найдем этот домен и разделим его на части: отделим имя домена от его зоны. Для этого мы используем специальные карманы регулярных выражений.
Карманы представляют собой элементы массива, в которые можно положить части найденного регуляркой. В нашем случае в первый карман мы можем положить имя домена, а во второй - его зону.
Давайте сделаем это. Для начала напишем регулярку, которая находит домен в строке:");
addBr(aC('$reg'." = '#[a-z0-9_-]+\.[a-z]{2,}#';"));
addBr("Давайте теперь в нашей регулярке обозначим, какие части в какой карман должны попадать. Это делается с помощью круглых скобок. Давайте выделим с их помощью часть регулярки, которая ищет имя домена, и ту часть, которая ищет доменную зону:");
addBr(aC('$reg'." = '#([a-z0-9_-]+)\.([a-z]{2,})#';"));
addBr("Теперь в функции preg_match в качестве третьего параметра укажем переменную (имя любое):");
addBr(aC('preg_match($reg, $str, $res);'));
addBr("В указанную переменную попадет массив с найденными карманами. При этом в нулевом элементе массива будет лежать найденная строка, в первом элементе - первый карман, во втором элементе - второй карман и так далее:");
addBr(aC("var_dump(".'$res'."); // выведет ['site.ru', 'site', 'ru'];"));
addBr("");
addBr(rB('Задача'));
addBr("Дана строка: ".'$str'." = '2025-12-31'; Положите год, месяц и день в отдельные карманы.");

$str = '2025-12-31';
$reg = '#(\d{4})\-(\d{2})\-(\d{2})#';
preg_match($reg, $str, $result);
echo(aC("preg_match('#(\d{4})\-(\d{2})\-(\d{2})#', '2025-12-31', ".'$result'."); var_dump(".'$result'.")").' = ');
var_dump($result);
hr();



addBr(rB("Поиск всех совпадений через регулярки на PHP"));
addBr("С помощью функции preg_match_all можно узнать количество всех совпадений с регулярным выражением:");

echo(aC('$str'." = 'a aa aaa bbb'; <br/>
echo preg_match_all('#a+#', ".'$str'.") = "));
addBr(preg_match_all('#a+#', 'a aa aaa bbb'));

addBr('Дана строка. Узнайте, сколько чисел в этой строке.');
addBr(aC('$str'." = '1 12 123';"));
echo(aC("preg_match_all('#\d#',". '$str'.")").' = ');
$str = '1 12 123';
$result = preg_match_all('#\d#', $str);
echo $result;
hr();



addBr('Все совпадения на карманы через регулярки в PHP');
addBr('С помощью функции preg_match_all можно разделить все найденные совпадения на карманы. Давайте посмотрим, как это делается.<br/>
Пусть, например, у нас есть строка с доменами:');
addBr(aC('$str'." = 'site.ru site123.com my-site.net';"));
addBr("Давайте напишем регулярное выражение на поиск домена, отделив имя и зону в отдельные карманы:");
addBr(aC('$reg'." = '#([a-z0-9_-]+)\.([a-z]{2,})#';"));
echo(aC("preg_match_all(".'$reg'.", ".'$str'.", ".'$res'.");<br/>
	print_r(".'$res'.");").' = ');
	preg_match_all('#([a-z0-9_-]+)\.([a-z]{2,})#', 'site.ru site123.com my-site.net',$result);
print_r($result);
addBr("В результате мы получим двухмерный массив. В нулевой элемент этого массива попадет содержимое нулевых карманов (то есть то, что попало под всю регулярку), во второй элемент - содержимое первых карманов и так далее:");
addBr(aC("[<br/>
		['site.ru', 'site123.com', 'my-site.net'],<br/>
		['site', 'site123', 'my-site'],<br/>
		['ru', 'com', 'net'],<br/>
	]"));
addBr(rB('Задача'));
addBr("Дана строка с датами:	" . '$str' . " = '2023-10-29 2024-11-30 2025-12-31' " . "Найдите все даты, отделив год, месяц и день в отдельные карманы.");
echo(aC('$str'." = '2023-10-29 2024-11-30 2025-12-31';<br/>
".'$reg'." = '#(\d{4})-(\d{2})-(\d{2})#';<br/>
preg_match_all(".'$reg'.", ".'$str'.", ".'$result'.");<br/>
print_r(".'$result'.");").' = ');

$str = '2023-10-29 2024-11-30 2025-12-31';
$reg = '#(\d{4})-(\d{2})-(\d{2})#';
preg_match_all($reg, $str, $result);
print_r($result);
hr();



addBr('Изменение поведения preg_match_all в PHP');
addBr('В функцию preg_match_all можно передать четвёртый параметр "flags" который будет изменять формирование массива совпадений. А так же 5й параметр, который будет указывать откуда вести поиск совпадений.');
addBr('С помощью четвертого параметра функции можно поменять способ группировки карманов. Подробную информацию об этом посмотрите по ссылке <a target="_blank" href="https://www.php.net/manual/ru/function.preg-match-all.php">https://www.php.net/manual/ru/function.preg-match-all.php</a>');
addBr(rB('Задача'));
addBr("Модифицируйте предыдущую задачу так, чтобы в первый подмассив попала первая дата с ее карманами, во второй подмассив - вторая с ее карманами и так далее.");
echo(aC('$str'." = '2023-10-29 2024-11-30 2025-12-31';<br/>
".'$reg'." = '#(\d{4})-(\d{2})-(\d{2})#';<br/>
preg_match_all(".'$reg'.", ".'$str'.", ".'$result'. ", PREG_SET_ORDER);<br/>
print_r(".'$result'.");").' = ');

$str = '2023-10-29 2024-11-30 2025-12-31';
$reg = '#(\d{4})-(\d{2})-(\d{2})#';
preg_match_all($reg, $str, $result, PREG_SET_ORDER);
print_r($result);
hr();



addBr(rB('Несохраняющие скобки в регулярках PHP'));
addBr('Скобки () выполняют две функции - группировка символов и функцию кармана. А что делать, если нам нужно сгруппировать, но в карман не класть? Для решения такой проблемы придуманы специальные несохраняющие скобки (?: ) - они группируют, но не кладут в карман.');
addBr(rB('Пример 1')); 
addBr("В следующем примере первые скобки нам нужны для группировки, а вторые - для кармана. Однако, и те, и другие скобки сохраняют данные в карман:<br/>".
aC(
'$str'." = 'abab123';<br/>
".'$reg'." = '#(ab)+([1-9]+)#';<br/>
preg_match_all(".'$reg'.", ".'$str'.", ".'$res'.");<br/>"));
$str = 'abab123';
$reg = '#(ab)+([1-9]+)#';
preg_match_all($reg, $str, $res);
addBr('В результате в наших карманах будет следующее:');
echo(aC('var_dump($res[0]);'));var_dump($res[0]); echo '<br/>'; // выведет 'abab123'
echo(aC('var_dump($res[1]);'));var_dump($res[1]); echo '<br/>'; // выведет 'ab'
echo(aC('var_dump($res[2]);'));var_dump($res[2]); echo '<br/>'; // выведет '123'
addBr('');

addBr(rB('Пример 2'));
addBr("В следующем примере первые скобки нам нужны для группировки, а вторые - для кармана. Однако, и те, и другие скобки сохраняют данные в карман:<br/>" .
	aC(
		'$str' . " = 'abab123';<br/>
" . '$reg' . " = '#(?:ab)+([1-9]+)#';<br/>
preg_match_all(" . '$reg' . ", " . '$str' . ", " . '$res' . ");<br/>"
	));
$str = 'abab123';
$reg = '#(?:ab)+([1-9]+)#';
preg_match_all($reg, $str, $res);
addBr('В результате в наших карманах будет следующее:');
echo (aC('var_dump($res[0]);'));
var_dump($res[0]);
echo '<br/>'; // выведет 'abab123'
echo (aC('var_dump($res[1]);'));
var_dump($res[1]);
echo '<br/>'; // выведет 'ab'

addBr(rB('Задача'));
addBr("Даны подстроки, разделенные на две части произвольным количеством пар $@: ".'$str'. " = 'aaa$@bbb aaa$@$@bbb aaa$@$@$@bbb'; Найдите каждую из таких подстрок и для каждой найденной подстроки положите в первый карман то, что стоит до разделителя, а во второй карман - то, что стоит после разделителя.");
echo(aC(
'$str' . " = 'abab123';<br/>
" . '$reg' . " = '#(a+)(?:\\$@)+(b+)#';<br/>
preg_match_all(" . '$reg' . ", " . '$str' . ", " . '$res' . ");<br/>
echo ".'$res'
).' = ');
$str = 'aaa$@bbb aaa$@$@bbb aaa$@$@$@bbb';
$reg = '#(a+)(?:\$@)+(b+)#';
preg_match_all($reg, $str, $result);
var_dump($result);
hr();



addBr(rB('Карманы при замене через регулярки на PHP'));
addBr('При работе с функцией preg_replace, если мы что-то положим в карман в регулярке, то в строке замены мы можем вставить содержимое этого кармана написав знак доллара $ и номер кармана. Например, $0 - нулевой карман, $1 - первый карман, $2 - второй карман и так далее.<br/>
Зачем это нужно и как этим пользоваться давайте посмотрим на примерах.');

addBr(rB('Пример 1'));
addBr("Давайте найдем все числа и вместо них вставим эти же числа, но в фигурных скобках. Для этого все найденные числа мы будем заменять на них самих же, но в фигурных скобках:<br/>" .
	aC(
		'$str' ." = '1 23 456 xax';<br/>".
	'$res'." = preg_replace('#(\d+)#', '{\$1}', ".'$str'.");"
	));
$str = '1 23 456 xax';
$res = preg_replace('#(\d+)#', '{$1}', $str);
addBr('В результате в переменную запишется следующее:');
addBr(aC('echo $res').' = '. $res);

addBr(rB('Пример 2'));
addBr("Давайте найдем все строки, представляющие собой числа с иксами вокруг и заменим эти числа на них же, но с '!' знаками вокруг:<br/>" .
	aC(
		'$str' ." = 'x1x x23x x456x xax';<br/>".
	'$res'." = preg_replace('#x(\d+)x#', '!$1!', ".'$str'.");"
	));
$str = 'x1x x23x x456x xax';
$res = preg_replace('#x(\d+)x#', '!$1!', $str);
addBr('В результате в переменную запишется следующее:');
addBr(aC('echo $res').' = '. $res);

addBr(rB('Пример 3'));
addBr("Давайте решим следующую задачу: даны строки вида 'aaa@bbb' - буквы, потом собака, потом буквы. Нужно поменять местами буквы до '@' и после. Реализуем:<br/>" .
	aC(
		'$str' ." = 'aaa@bbb ccc@ddd';<br/>".
	'$res'." = preg_replace('#([a-z]+)@([a-z]+)#', '$2\\$$1', ".'$str'.");"
	));
$str = 'aaa@bbb ccc@ddd';
$res = preg_replace('#([a-z]+)@([a-z]+)#', '$2\$$1', $str);
addBr('В результате в переменную запишется следующее:');
addBr(aC('echo $res').' = '. $res);
addBr("");
addBr(rB('Практические задачи'));
addBr('Дана строка:	$str'." = '12 34 56 78';".' Поменяйте местами цифры во всех двухзначных числах.');
$str = '12 34 56 78';
$res = preg_replace('#(\d)(\d)#','$2$1',$str );
addBr(aC("preg_replace('#(\d)(\d)#','$2$1','12 34 56 78'").' = '.$res);
addBr('');
addBr('Дана строка с датой:	$str'. " = '31.12.2025';"." Преобразуйте эту дату в '2025.12.31'.");
$str = '31.12.2025';
$res = preg_replace('#(\d+)\.(\d+)\.(\d+)#','$3.$2.$1',$str );
addBr(aC("preg_replace('#(\d+)\.(\d+)\.(\d+)#','$3.$2.$1','12 34 56 78'").' = '.$res);
hr();



addBr(rB('Карманы в регулярном выражении в PHP'));
addBr('Содержимое карманов доступно не только в строке замены, но в и самой регулярке: мы можем положить что-нибудь в карман, а затем прямо в регулярке сказать, что здесь должно стоять содержимое этого кармана.<br/>
Содержимое карманов доступно по их номерам, перед которыми стоит обратный слеш. Например, нулевой карман будет доступен вот так: \0, первый карман вот так - \1, второй - \2 и так далее.<br/>
Уверен, что все написанное выше пока весьма туманно для вас. Это не удивительно, так какие карманы - самое малопонятное место регулярок. Давайте будем разбираться на примерах.');

addBr(rB('Пример 1'));
addBr("Пусть у нас есть вот такая строка: ".'$str'." = 'aa bb cd ef'". " Давайте найдем в ней все места, в которых стоят две любые одинаковые буквы подряд. Для решения задачи будем искать любую букву, класть ее в карман, а затем проверять, идет ли следующем символом содержимое этого кармана:<br/>" .
aC(
	'$res'. " = preg_replace('#([a-z])\\1#', '!', 'aa bb cd ef');"
));
$str = 'aa bb cd ef';
$res = preg_replace('#([a-z])\\1#', '!', $str);
addBr('В результате в переменную запишется следующее:');
addBr(aC('echo $res').' = '. $res);

addBr(rB('Пример 2'));
addBr("Пусть у нас есть вот такая строка: ".'$str'. " = 'asxca buzxb csgd'". " Давайте найдем в ней все слова, в которых одинаковы первая и последняя буквы. Для решения задачи напишем следующий шаблон: буква, затем еще одна или более букв, а затем такая же буква как первая:<br/>" .
	aC(
	'$res'. " = preg_replace('#([a-z])[a-z]+\\1#', '!', 'asxca buzxb csgd');"
	));
$str = 'aa bb cd ef';
$res = preg_replace('#([a-z])[a-z]+\1#', '!', 'asxca buzxb csgd');
addBr('В результате в переменную запишется следующее:');
addBr(aC('echo $res').' = '. $res);
addBr(rB("Вместо \\1 можно писать \g1 или Можно также писать \g{1}. В фигурных скобках можно указывать отрицательные числа \g{-2}. В этом случае карманы будут отсчитываться с конца:"));

addBr(rB('Практические задачи'));
addBr('Дана строка:	$str' . " = 'aaa bbb ccc xyz';" . ' Найдите все подстроки, в которых есть три одинаковые буквы подряд.');
addBr(aC(
	'$res'. " = preg_replace('#([a-z])\\1\\1#', '!', 'aaa bbb ccc xyz');"
));
$str = 'aaa bbb ccc xyz';
$res = preg_replace('#([a-z])\1\1#', '!', $str);
addBr(aC('echo $res').' = '. $res);
addBr(aC('$res'. " = preg_replace('#([a-z])\\g1\\g{-1}#', '!', 'aaa bbb ccc xyz');"));
$str = 'aaa bbb ccc xyz';
$res = preg_replace('#([a-z])\g1\g{-1}#', '!', $str);
addBr(aC('echo $res').' = '. $res);

addBr('');
addBr('Дана строка:	$str' . " = 'a aa aaa abab bbbb';" . ' Найдите все подстроки, в которых есть две и более одинаковые буквы подряд.');
addBr(aC('$res'. " = preg_replace('#([a-z])\\1+#', '!', 'a aa aaa abab bbbb');"));
$str = 'a aa aaa abab bbbb';
$res = preg_replace('#([a-z])\1+#', '!', $str);
addBr(aC('echo $res').' = '. $res);

addBr('');
addBr('Дана строка:	$str' . " = 'aaa aaa bbb bbb ccc ddd py py';" . ' Найдите все подстроки, в которых есть два одинаковых слова подряд.');
addBr(aC('$res'. " = preg_replace('#([a-z]+)\\s\\1#', '!', 'aaa aaa bbb bbb ccc ddd py py');"));
$str = 'aaa aaa bbb bbb ccc ddd py py';
$res = preg_replace('#([a-z]+)\s\1#', '!', $str);
addBr(aC('echo $res').' = '. $res);
hr();



addBr(rB('Именованные карманы в регулярках PHP'));
addBr('Пусть с помощью preg_match мы хотим разбить дату на день, месяц и год. Используем для этого карманы:');
echo(aC(
'$str'. " = '2025-10-29';".'<br/>'.
'$reg'. " = '#(\d{4})-(\d{2})-(\d{2})#'".'<br/>'.
'preg_match($reg, $str, $match);<br/>
var_dump($match)'
).' = ');
$str = '2025-10-29';
$reg = '#(\d{4})-(\d{2})-(\d{2})#';
preg_match($reg, $str, $match);
var_dump($match);
addBr('');
addBr('Как вы видите, в результате мы получаем массив, в котором в нулевом элементе будет вся дата, в первом - год, во втором - месяц, в третьем - день. Иногда, однако, было бы удобно получить содержимое карманов в виде ассоциативного массива. То есть в нашем случае было бы неплохо получить вот такой массив:');
addBr(aC("
[<br/>
'year'  => '2025',<br/>
'month' => '10',<br/>
'day'   => '29'<br/>
]
"));
addBr('Для этого в регулярках существует специальный синтаксис. Вот он: (?' . htmlspecialchars('<name>').'pattern), где pattern - это регулярка, а name - это имя кармана. Давайте перепишем нашу регулярку для даты через именованные карманы:');
$str = '2025-10-29';
$reg = '#(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})#';
preg_match($reg, $str, $match);
echo(aC(
'$str'. " = '2025-10-29';".'<br/>'.
'$reg'. " = '#(?".htmlspecialchars('<year>'). "\d{4})-(?" . htmlspecialchars('<month>')."\d{2})-(?".htmlspecialchars('<day>')."\d{2})#'".'<br/>'.
'preg_match($reg, $str, $match);<br/>
var_dump($match)'
).' = ');
var_dump($match);
addBr('В результате у нас получится ассоциативный массив, в котором ключами будут имена карманов, а значениями - то, что в них попало:');
addBr(aC("
[<br/>
'year'  => '2025',<br/>
'month' => '10',<br/>
'day'   => '29'<br/>
]
"));
addBr(rB("На самом деле в массиве с результатом значения карманов будут доступны как по имени, так и по порядковому номеру. То есть, к примеру, год будет доступен по ключу 'year' и по номеру 1, месяц - по ключу 'month' и по номеру 2 и так далее:"));
addBr(aC("
[<br/>
'year'  => '2025',<br/>
'month' => '10',<br/>
'day'   => '29'<br/>

1       => '2025',<br/>
2       => '10',<br/>
3       => '29'<br/>
]
"));
addBr(rB("Описанные именованные карманы имеют еще несколько альтернативных синтаксисов: (?P" . htmlspecialchars('<name>')."pattern) и (?'name'pattern)."));
addBr('');
addBr(rB('Практическая задача'));
addBr('Дана строка со временем:	$str' . " = '12:59:58';" . ' Положите часы, минуты и секунды в отдельные именованные карманы.');
$str = '12:59:58';
$reg = '#(?<hour>\d{2}):(?<min>\d{2}):(?<sec>\d{2})#';
preg_match($reg, $str, $result);
var_dump($result);
addBr('');
addBr('Напишите функцию, которая в массиве с результатом удалит все нумерованные карманы, оставив только именованные.');
function delNumKey($arr){
	$newArr =[];
	foreach($arr as $key => $el) {
		$flag = preg_match('#\d#', $key);
		if(!$flag){
			$newArr[$key] = $el;
		};
	}
	return $newArr;
}
var_dump(delNumKey($result));

hr();
		
		
		
addBr(rB('Именованные карманы внутри регулярки PHP'));
addBr('Вспомним, как мы пользовались карманами в самом регулярном выражении:');
addBr(aC('$res'. " = preg_replace('#([a-z])\\1#', '!', ".'$str'.");"));
addBr('Иногда бывают ситуации, когда удобнее обращаться к карману не по его номеру, а по имени. Для этого нам нужно дать карману имя:');
addBr(aC('$res'. " = preg_replace('#(?".htmlspecialchars('<letter>')."[a-z])#', '!', ".'$str'.");"));
addBr('Теперь мы можем обратиться к этому карману через синтаксис \\k'.htmlentities('<name>').', вот так:');
addBr(aC('$res'. " = preg_replace('#(?<letter>[a-z])\k".htmlspecialchars('<letter>')."#', '!', ".'$str'.");"));
addBr('Описанные именованные карманы имеют еще несколько альтернативных синтаксисов: (?P=name), \\k'."name".', \\k{name}.');

addBr('');
addBr(rB('Практическая задача'));
addBr('Дана строка со временем:	$str' . " = '12:59:59 12:59:12 09:45:09';" . ' Найдите все подстроки со временем, в которых час совпадает с секундами.');
$str = '12:59:59 12:59:12 09:45:09';
$res = preg_replace('#(?<hour>\d{2}):(\d{2}):\k<hour>#','hour == sec', $str);
addBr(aC('$res'. " = preg_replace('#(?".htmlspecialchars('<hour>'). "\d{2}):(\d{2}):\k" . htmlspecialchars('<hour>') . "#','hour == sec','12:59:59 12:59:12 09:45:09')"));
addBr(aC('echo $res').' = '.$res);
hr();




addBr(rB('Общий номер карманов в регулярках PHP'));
addBr('Рассмотрим следующую ситуацию. Пусть у нас есть переменная с годом, который может изменяться от 1990 до 2099. Пусть мы хотим получать последние две цифры года в карман. Напишем соответствующую регулярку:');
addBr(aC('$res' . " = '#19(9\d)|20(\d\d)#';"));
addBr('Нас, однако, здесь поджидает одно неудобство. Дело в том, что для годов прошлого века две цифры будут попадать в первый карман, а для годов второго века - во второй. Посмотрим на примерах.

Вот первый вариант:');
addBr(aC(
	'$str'." = '1991';<br/>
	preg_match(".'$reg'.", ".'$str'.", ".'$res'.");<br/>
	var_dump(".'$res'."); 
	")."// [1 => '91']");

addBr('Вот второй вариант:');
addBr(aC(
	'$str'." = '2021';<br/>
	preg_match(".'$reg'.", ".'$str'.", ".'$res'.");<br/>
	var_dump(".'$res'."); 
	")."// [2 => '21']");
	
addBr('Пусть теперь мы хотим записать найденные цифры года в переменную. Нас ждет проблема, ведь мы не знаем точно, с каким ключом забирать данные из кармана:');
addBr(aC('$year = $res[1];')." // нужен ключ или 1, или 2");

addBr('Можно решить проблему через условие. Однако, есть решение попроще. Можно использовать специальную команду (?| ). Все карманы, которые находятся внутри нее будут иметь один номер.
Давайте исправим нашу регулярку: ');
addBr(aC('$reg'." = '#(?|19(9\d)|20(\d\d))#';"));
addBr('И теперь наш год точно будет в кармане с номером один:'.aC(' $year = $res[1]'));

addBr('');
addBr(rB('Практическая задача'));
addBr('Даны строки с датами, в которых год может изменяться от 1990 до 2099:<br/>	$arr' . " = [<br/>
		'31-12-2025',<br/>
		'30-11-1995',<br/>
		'29-10-1990',<br/>
	];<br/>" . ' Найдите все подстроки со временем, в которых час совпадает с секундами.');
$arr = [
	'31-12-2025',
	'30-11-1995',
	'29-10-1990',
];
// $res = preg_replace('#(?<hour>\d{2}):(\d{2}):\k<hour>#', 'hour == sec', $str);
// addBr(aC('$res' . " = preg_replace('#(?" . htmlspecialchars('<hour>') . "\d{2}):(\d{2}):\k" . htmlspecialchars('<hour>') . "#','hour == sec','12:59:59 12:59:12 09:45:09')"));
// addBr(aC('echo $res') . ' = ' . $res);
hr();

?>



